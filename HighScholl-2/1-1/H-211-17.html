<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<title>데이터의 압축</title>
		<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=0.5, maximum-scale=3, user-scalable=yes">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="format-detection" content="telephone=no">
		<link rel="stylesheet" href="GoogleTranslate.css">
		<link rel="stylesheet" href="./css/jquery-ui.min.css">
		<link rel="stylesheet" href="./css/swiper.css">
		<link rel="stylesheet" href="./css/fonts.css">
		<link rel="stylesheet" href="./css/style.css">
		<link rel="stylesheet" href="./css/common_all.css">
		<script src="https://tbacdn.kosac.re.kr/js/aidtScript.js"></script>
		<script type="text/javascript" src="GoogleTranslate.js"></script>
		<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=GoogleTranslateInitCallback"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
		<script src="./js/jquery-ui.min.js"></script>
		<script src="./js/swiper.js"></script>
		<style>
			.drop-zone {
				transition: all 0.2s ease;
			}

			.drop-zone.dragover {
				background-color: #e9ecef;
				border-color: #007bff;
			}

			.drop-zone.occupied {
				border-style: solid;
			}

			.draggable {
				cursor: move;
				cursor: -webkit-grab;
				cursor: grab;
				user-select: none;
				/*transition: all 0.2s ease;*/
			}

			.draggable.dragging {
				opacity: 0.5;
				cursor: -webkit-grabbing;
				cursor: grabbing;
			}

			.sr-only {
				position: absolute;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0, 0, 0, 0);
				border: 0;
			}
		</style>
	</head>
	<body>
		<div id="wrap">
			<main class="H_211_17_con">
				<div class="contents_con">
					<div class="title_con">
						<div class="contents_con">
							<div class="text_bg">
								<h3 class="text01" tabindex="0">반복</h3>
								<h2 class="text02" tabindex="0">개념 다지기</h2>
								<div class="bg"></div>
							</div>
							<div class="text_con" tabindex="0">
								<h1> 1-1. 데이터의 압축 </h1>
							</div>
						</div>
					</div>
					<div class="contents_con">
						<!-- slider -->
						<div class="slide_wrap_con">
							<div class="slide_con">
								<div class="swiper-container H_211_17_slide">
									<div class="swiper-wrapper" role="region" aria-label="데이터의 암호화 슬라이드">
										<div class="swiper-slide H_211_17_slide_01" data-swiper-autoplay="4000" role="group" aria-label="">
											<div class="num_title text_01">
												<span class="number_icon type_purple">1</span> 디지털 데이터 압축
											</div>
											<ul class="list-bullet">
												<li>
													<div class="blank_con drop-zone" role="region" aria-label="첫번째 답변 영역" data-position="1" tabindex="0">
														<span class="sr-only">답변을 이 곳에 놓으세요</span>
													</div> : 원본 데이터를 더 작은 용량의 데이터로 만드는 것을 의미함.
												</li>
												<li> 데이터 압축의 필요성 <div class="both_wrap">
														<div class="item">
															<div class="tit f_center rd_10">데이터 저장 공간 절감</div>
															<div class="con f_center rd_10"> 한정된 저장 공간 안에 <br /> 더 많은 데이터를 <br /> 저장할 수 있음. </div>
														</div>
														<div class="item">
															<div class="tit f_center rd_10">데이터 전송 시간 단축</div>
															<div class="con f_center rd_10"> 데이터를 빠르게 전송하여, <br /> 효과적으로 데이터를 <br /> 공유할 수 있음. </div>
														</div>
														<div class="item">
															<div class="tit f_center rd_10">데이터 관련 비용 절감</div>
															<div class="con f_center rd_10"> 클라우드에 데이터를 <br /> 올릴 때 업로드 용량을 <br /> 줄여, 클라우드 비용을 <br /> 줄일 수 있음. </div>
														</div>
														<div class="item">
															<div class="tit f_center rd_10">전기 사용을 줄여 <br /> 환경에 기여 </div>
															<div class="con f_center rd_10"> 대규모 데이터 관리 및 <br /> 전송에 필요한 전기 사용을 <br /> 줄여 환경적인 측면에서 <br /> 이점이 있음. </div>
														</div>
													</div>
												</li>
											</ul>
										</div>
										<div class="swiper-slide H_211_17_slide_02" data-swiper-autoplay="4000" role="group" aria-label="">
											<div class="num_title text_01">
												<span class="number_icon type_purple">2</span> 데이터 압축 방법
											</div>
											<ul class="list-bullet">
												<li>
													<div class="blank_con drop-zone" role="region" aria-label="두번째 답변 영역" data-position="2" tabindex="0">
														<span class="sr-only">답변을 이 곳에 놓으세요</span>
													</div> : 데이터 손실 없이 압축하는 방법으로, 대표적인 예로 런 길이 부호화와 사전 압축이 있음. <ul class="list_dash">
														<li>런 길이 부호화: 동일한 데이터가 몇 번 반복되는지 기록하여 데이터를 짧게 만드는 방식</li>
														<li>사전 압축: 원본 데이터를 나열한 후 코드를 붙여 만든 사전을 바탕으로 압축하는 방식</li>
													</ul>
												</li>
												<li>
													<div class="blank_con drop-zone" role="region" aria-label="세번째 답변 영역" data-position="3" tabindex="0">
														<span class="sr-only">답변을 이 곳에 놓으세요</span>
													</div> : 데이터 손실이 있는 압축 방법으로 이미지, 영상, 소리 데이터를 압축할 때 효율적임. <ul class="list_dash">
														<li>이미지 데이터 압축: 픽셀 수나 각 픽셀에 저장된 데이터를 줄여 압축하는 방법, JPEG이 있음.</li>
														<li>영상 데이터 압축: 변화하는 정보만 저장하여 압축하는 방법, MPEG이 있음.</li>
														<li>소리 데이터 압축: 아날로그 데이터를 표본화, 양자화, 부호화 과정을 거쳐 디지털 신호로 변환함.</li>
													</ul>
												</li>
											</ul>
										</div>
									</div>
								</div>
							</div>
							<div class="slide_btn prev swiper-button-prev H_211_17_slide_prev_btn" aria-label="슬라이드 이전 버튼" tabindex="0"></div>
							<div class="slide_btn next swiper-button-next H_211_17_slide_next_btn" aria-label="슬라이드 다음 버튼" tabindex="0"></div>
						</div>
						<!-- //slider -->
						<div class="answer_con">
							<div class="title_con" tabindex="0">
								<span> 빈칸에 알맞은 말을 옮겨 보자. </span>
							</div>
							<div class="contents_con options-container" role="region" aria-label="사용 가능한 답변들">
								<span class="draggable" draggable="true" role="button" aria-grabbed="false" data-answer="3" tabindex="0"> 손실 압축 </span>
								<span class="draggable" draggable="true" role="button" aria-grabbed="false" data-answer="1" tabindex="0"> 데이터 압축 </span>
								<span class="draggable" draggable="true" role="button" aria-grabbed="false" data-answer="2" tabindex="0"> 무손실 압축 </span>
							</div>
							<div class="btn_con">
								<button  class="a_btn a_btn01 check-btn" type="button" aria-label="확인하기" tabindex="0">확인하기</button>
								<button  class="a_btn a_btn02 retry-btn" type="button" aria-label="다시 하기" style="display: none;" tabindex="0">다시 하기</button>
							</div>
						</div>
						<div class="popup_con_bg popup01"></div>
						<div class="popup_con popup01" role="alert"></div>
						<div class="popup_con_bg popup02"></div>
						<div class="popup_con popup02" role="alert"></div>
						<div class="popup_con_bg popup03"></div>
						<div class="popup_con popup03" role="alert"></div>
						<div class="popup_con_bg popup04"></div>
						<div class="popup_con popup04" role="alert"></div>
					</div>
				</div>
			</main>
			<script>
				document.addEventListener('DOMContentLoaded', () => {
					const initialOrder = [];
					let try_check = 0;
					let isAnswered = false;
					const checkButton = document.querySelector('.check-btn');
					const retryButton = document.querySelector('.retry-btn');
					let dropZones = document.querySelectorAll('.drop-zone');
					const swiperInstance = new Swiper('.H_211_17_slide', {
						slidesPerView: 'auto',
						effect: 'fade',
						fadeEffect: {
							crossFade: true
						},
						speed: 100,
						loop: false,
						navigation: {
							nextEl: '.H_211_17_slide_next_btn',
							prevEl: '.H_211_17_slide_prev_btn',
						},
						observer: true,
						observeParents: true,
						simulateTouch: false,
						allowTouchMove: false,
						on: {
							slideChange: function() {
								const isLast = this.activeIndex === this.slides.length - 1;
								checkButton.style.display = 'none';
								retryButton.style.display = 'none';
								if (isLast) {
									if (isAnswered || try_check >= 2) {
										retryButton.style.display = 'inline-block';
									} else {
										checkButton.style.display = 'inline-block';
									}
								}
							}
						}
					});
					swiperInstance.emit('slideChange');
					const draggables = document.querySelectorAll('.draggable');
					const optionsContainer = document.querySelector('.options-container');
					let draggedElement = null;
					let isDragging = false;
					let startX, startY, initialX, initialY, xOffset = 0,
						yOffset = 0;
					let adapt_answer = 0; // 적용한 답변 수
					let correct_answer = 0; // 정답 수
					// 각 요소의 초기 위치와 순서를 저장할 객체
					const originalPositions = {};
					// 초기 위치 저장
					const originalOrder = [...optionsContainer.children].map(child => child.dataset.answer);
					// 모든 항목을 원래 자리로 이동
					const returnItemsToContainer = () => {
						// 모든 드래그 요소를 일단 임시 배열에 모으기
						const items = [];
						dropZones.forEach(zone => {
							const draggable = zone.querySelector('.draggable');
							if (draggable) {
								items.push(draggable);
								zone.classList.remove('occupied');
							}
						});
						// 현재 options-container에 있는 요소들
						const currentItems = [...optionsContainer.querySelectorAll('.draggable')];
						// 모든 요소를 합치기
						const allItems = [...items, ...currentItems];
						// 원래 순서대로 정렬
						allItems.sort((a, b) => {
							const indexA = originalOrder.indexOf(a.dataset.answer);
							const indexB = originalOrder.indexOf(b.dataset.answer);
							return indexA - indexB;
						});
						// options-container의 모든 draggable 요소 제거
						currentItems.forEach(item => item.remove());
						// 정렬된 순서대로 options-container에 추가
						allItems.forEach(item => {
							optionsContainer.appendChild(item);
						});
						adapt_answer = 0;
						correct_answer = 0;
					};
					// 모든 항목을 정답 자리로 이동
					const placeItemsInCorrectPositions = () => {
						returnItemsToContainer();
						draggables.forEach(item => {
							const correctZone = Array.from(dropZones).find(zone => zone.dataset.position === item.dataset.answer);
							if (correctZone) {
								correctZone.appendChild(item);
								correctZone.classList.add('occupied');
							}
						});
					};
					// 터치 이벤트 처리 함수
					function dragStart(e) {
						if (e.type === "touchstart") {
							initialX = e.touches[0].clientX;
							initialY = e.touches[0].clientY;
							draggedElement = e.target;
						} else {
							initialX = e.clientX;
							initialY = e.clientY;
							draggedElement = e.target;
						}
						if (draggedElement.classList.contains('draggable')) {
							isDragging = true;
							// 원본 요소의 스타일과 위치 정보를 저장
							const rect = draggedElement.getBoundingClientRect();
							const width = rect.width;
							const height = rect.height;
							xOffset = initialX - rect.left;
							yOffset = initialY - rect.top;
							// 먼저 클론을 생성해서 원본 요소 위에 위치시키기
							const clone = draggedElement.cloneNode(true);
							clone.id = 'dragging-clone';
							clone.style.position = 'fixed';
							clone.style.width = width + 'px';
							clone.style.height = height + 'px';
							clone.style.left = rect.left + 'px';
							clone.style.top = rect.top + 'px';
							clone.style.zIndex = '1000';
							clone.style.opacity = '0.8';
							clone.style.pointerEvents = 'none';
							// 원본 스타일 복사
							const originalStyle = window.getComputedStyle(draggedElement);
							clone.style.backgroundColor = originalStyle.backgroundColor;
							clone.style.border = originalStyle.border;
							clone.style.borderRadius = originalStyle.borderRadius;
							clone.style.borderColor = originalStyle.borderColor;
							clone.style.color = originalStyle.color;
							clone.style.fontFamily = originalStyle.fontFamily;
							clone.style.fontSize = originalStyle.fontSize;
							clone.style.fontWeight = originalStyle.fontWeight;
							clone.style.padding = originalStyle.padding;
							clone.style.boxShadow = '2px 2px 5px rgba(0,0,0,0.2)';
							clone.style.cursor = 'grabbing';
							clone.style.lineHeight = originalStyle.lineHeight;
							clone.style.textAlign = originalStyle.textAlign;
							document.body.appendChild(clone);
							// 원본 요소는 보이지 않게 설정
							draggedElement.style.visibility = 'hidden';
							// 클론 요소를 draggedElement의 속성으로 저장
							draggedElement.cloneElement = clone;
							// 드래깅 클래스는 더이상 사용하지 않음
							// clone.classList.add('dragging');
						}
					}

					function dragEnd(e) {
						if (isDragging && draggedElement) {
							// 클론 요소 가져오기
							const clone = draggedElement.cloneElement;
							const dropTarget = document.elementFromPoint(e.type === "touchend" ? e.changedTouches[0].clientX : e.clientX, e.type === "touchend" ? e.changedTouches[0].clientY : e.clientY);
							if (dropTarget) {
								const dropZone = dropTarget.closest('.drop-zone');
								if (dropZone) {
									// 이미 드롭존에 항목이 있는 경우
									const existingDraggable = dropZone.querySelector('.draggable');
									if (existingDraggable && existingDraggable !== draggedElement) {
										// 기존 항목을 options-container에 원래 위치로 이동
										const optionsItems = [...optionsContainer.querySelectorAll('.draggable')];
										const index = originalOrder.indexOf(existingDraggable.dataset.answer);
										let inserted = false;
										// 원래 순서에 맞게 삽입
										for (let i = 0; i < optionsItems.length; i++) {
											const currentIndex = originalOrder.indexOf(optionsItems[i].dataset.answer);
											if (currentIndex > index) {
												optionsContainer.insertBefore(existingDraggable, optionsItems[i]);
												inserted = true;
												break;
											}
										}
										// 마지막 위치에 삽입
										if (!inserted) {
											optionsContainer.appendChild(existingDraggable);
										}
									}
									// 새 항목을 드롭존에 추가
									dropZone.appendChild(draggedElement);
									dropZone.classList.add('occupied');
								} else {
									// options-container로 이동할 때 원래 순서 유지
									const optionsItems = [...optionsContainer.querySelectorAll('.draggable')];
									const index = originalOrder.indexOf(draggedElement.dataset.answer);
									let inserted = false;
									// 원래 순서에 맞게 삽입
									for (let i = 0; i < optionsItems.length; i++) {
										const currentIndex = originalOrder.indexOf(optionsItems[i].dataset.answer);
										if (currentIndex > index) {
											optionsContainer.insertBefore(draggedElement, optionsItems[i]);
											inserted = true;
											break;
										}
									}
									// 마지막 위치에 삽입
									if (!inserted) {
										optionsContainer.appendChild(draggedElement);
									}
								}
							} else {
								// options-container로 이동할 때 원래 순서 유지
								const optionsItems = [...optionsContainer.querySelectorAll('.draggable')];
								const index = originalOrder.indexOf(draggedElement.dataset.answer);
								let inserted = false;
								// 원래 순서에 맞게 삽입
								for (let i = 0; i < optionsItems.length; i++) {
									const currentIndex = originalOrder.indexOf(optionsItems[i].dataset.answer);
									if (currentIndex > index) {
										optionsContainer.insertBefore(draggedElement, optionsItems[i]);
										inserted = true;
										break;
									}
								}
								// 마지막 위치에 삽입
								if (!inserted) {
									optionsContainer.appendChild(draggedElement);
								}
							}
							// 클론 요소 제거
							if (clone) {
								document.body.removeChild(clone);
								draggedElement.cloneElement = null;
							}
							// 원본 요소 복원
							draggedElement.style.visibility = 'visible';
							isDragging = false;
							draggedElement = null;
						}
					}

					function drag(e) {
						if (isDragging && draggedElement) {
							e.preventDefault();
							let currentX, currentY;
							if (e.type === "touchmove") {
								currentX = e.touches[0].clientX;
								currentY = e.touches[0].clientY;
							} else {
								currentX = e.clientX;
								currentY = e.clientY;
							}
							// 클론 요소 이동
							const clone = draggedElement.cloneElement;
							if (clone) {
								const newX = currentX - xOffset;
								const newY = currentY - yOffset;
								clone.style.left = `${newX}px`;
								clone.style.top = `${newY}px`;
							}
							// 드롭존 하이라이트
							const dropTarget = document.elementFromPoint(currentX, currentY);
							if (dropTarget) {
								const dropZone = dropTarget.closest('.drop-zone');
								dropZones.forEach(zone => {
									if (zone === dropZone && zone.children.length <= 1) {
										zone.classList.add('dragover');
									} else {
										zone.classList.remove('dragover');
									}
								});
							}
						}
					}
					// 드래그 앤 드롭 이벤트 처리
					draggables.forEach(draggable => {
						draggable.addEventListener('dragstart', (e) => {
							e.preventDefault(); // 기본 드래그 동작 방지
							return false;
						});
						// 마우스 이벤트
						draggable.addEventListener('mousedown', (e) => {
							e.preventDefault();
							dragStart(e);
						});
						// 터치 이벤트
						draggable.addEventListener('touchstart', (e) => {
							e.preventDefault();
							dragStart(e);
						}, {
							passive: false
						});
						draggable.addEventListener('touchmove', drag, {
							passive: false
						});
						draggable.addEventListener('touchend', dragEnd, {
							passive: false
						});
						// 클릭 이벤트 - drop-zone에 있는 요소를 클릭하면 원래 위치로 이동
						draggable.addEventListener('click', (e) => {
							// 드래그 중이 아닐 때만 클릭 처리
							if (!isDragging) {
								const parentElement = draggable.parentElement;
								if (parentElement && parentElement.classList.contains('drop-zone')) {
									// drop-zone에 있는 경우에만 옮기기
									parentElement.classList.remove('occupied');
									// options-container로 이동할 때 원래 순서 유지
									const optionsItems = [...optionsContainer.querySelectorAll('.draggable')];
									const index = originalOrder.indexOf(draggable.dataset.answer);
									let inserted = false;
									// 원래 순서에 맞게 삽입
									for (let i = 0; i < optionsItems.length; i++) {
										const currentIndex = originalOrder.indexOf(optionsItems[i].dataset.answer);
										if (currentIndex > index) {
											optionsContainer.insertBefore(draggable, optionsItems[i]);
											inserted = true;
											break;
										}
									}
									// 마지막 위치에 삽입
									if (!inserted) {
										optionsContainer.appendChild(draggable);
									}
								}
							}
						});
					});
					// 마우스 전역 이벤트
					document.addEventListener('mousemove', (e) => {
						if (isDragging) {
							drag(e);
						}
					});
					document.addEventListener('mouseup', (e) => {
						if (isDragging) {
							dragEnd(e);
						}
					});
					// 기본 드래그 방지
					document.addEventListener('dragstart', (e) => {
						e.preventDefault();
						return false;
					}, {
						passive: false
					});
					// 정답 확인 이벤트 처리
					checkButton.addEventListener('click', () => {
						dropZones.forEach(zone => {
							const answer = zone.querySelector('.draggable');
							if (answer) {
								adapt_answer++; // 답변 수
								const isCorrect = answer.dataset.answer === zone.dataset.position;
								if (isCorrect) correct_answer++; // 정답 수
							}
						});
						if (adapt_answer !== 3) {
							$(".popup01, .popup_con_bg.popup01").fadeIn();
							setTimeout(() => $(".popup01, .popup_con_bg.popup01").fadeOut(), 1000);
						} else {
							try_check++;
							if (correct_answer === 3) {
								isAnswered = true;
								$(".popup04, .popup_con_bg.popup04").fadeIn();
								setTimeout(() => {
									$(".popup04, .popup_con_bg.popup04").fadeOut();
								}, 1000);
								swiperInstance.emit('slideChange');
								checkButton.style.display = 'none';
								retryButton.style.display = 'inline-block';
							} else if (try_check === 1) {
								$(".popup02, .popup_con_bg.popup02").fadeIn();
								setTimeout(() => {
									$(".popup02, .popup_con_bg.popup02").fadeOut();
									returnItemsToContainer();
								}, 1000);
							} else if (try_check === 2) {
								$(".popup03, .popup_con_bg.popup03").fadeIn();
								setTimeout(() => {
									$(".popup03, .popup_con_bg.popup03").fadeOut();
									swiperInstance.emit('slideChange');
								}, 1000);
								setTimeout(() => placeItemsInCorrectPositions(), 500);
								checkButton.style.display = 'none';
								retryButton.style.display = 'inline-block';
							}
						}
					});
					retryButton.addEventListener('click', () => {
						checkButton.style.display = 'inline-block';
						retryButton.style.display = 'none';
						try_check = 0;
						isAnswered = false;
						returnItemsToContainer();
						swiperInstance.emit('slideChange');
					});
					// 드롭존 이벤트 처리
					const dropTargets = [...dropZones, optionsContainer];
					dropTargets.forEach(target => {
						target.addEventListener('dragover', (e) => {
							e.preventDefault();
							if (target.classList.contains('drop-zone') && target.children.length > 1) {
								return; // 이미 답변이 있는 경우 드롭 불가
							}
							target.classList.add('dragover');
						});
						target.addEventListener('dragleave', () => {
							target.classList.remove('dragover');
						});
						target.addEventListener('drop', (e) => {
							e.preventDefault();
							target.classList.remove('dragover');
							if (!draggedElement) return;
							// 드롭존인 경우 검증
							if (target.classList.contains('drop-zone')) {
								if (target.children.length > 1) return; // 이미 답변이 있으면 무시
								target.classList.add('occupied');
							} else {
								// 옵션 컨테이너로 돌아가는 경우
								draggedElement.parentElement.classList.remove('occupied');
							}
							target.appendChild(draggedElement);
						});
					});
				});
			</script>
		</div>
		<script>
			const contentId = 'H-211-17';
		</script>
		<script type="text/javascript" src="./js/xapi.page.js"></script>
	</body>
</html>